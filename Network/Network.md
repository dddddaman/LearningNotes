## 1、计算机网络分层



计算机网络中会把网络结构分层，目前主要有2种

* 7层 （osi国际标准组织定制）
* 4层（tcp/ip标准，美国军方制定）

#### 7层：物链网输会使用

1. 应用层：用户交互。协议：FTP（文件传输协议），SMTP（电子邮件传输协议），HTTP（超文本传输协议）
2. 表示层：数据处理（加密，格式转换，压缩和恢复），人类语言变成机器语言。协议：ASCII码       
3. 会话层：建立连接，添加校验点，在链接失效时重新连接同步数据（大文件传输）。协议：ADSP，ASP
4. 传输层：端到端通讯，两个主机的进程之间的数据传输和通讯（可靠传输，不可靠传输）。协议：TCP（可靠传输，3次握手保证建立连接，双工通讯（双方同时发送和接受数据），利用缓存保证数据完整有序，添加了序号和确认号验证数据完整性（比如3次握手演示中中经常出现的的seq和ack），电子邮件一类的一般使用这个，保证可靠性，不用太在意即时性），UDP（不可靠传输，一直发送，没有流量控制（有多少发多少），不纠错，一般视频会议一类的使用这个，保证数据速度和即时性，偶尔掉帧什么的无所谓）
5. 网络层： 选择最佳路径，控制发送端流量，纠错（保证传输层数据正确），阻塞控制（控制整体流量）。协议：IP
6. 数据链路层：数据组装成帧（把一个大数据分成一个一个的数据帧101010101010011。。。方便物理层传输）
7. 物理层：物理媒体上数据比特流的透明传输 （把 0 1 数据帧变成高低电压信号传输出去）。协议：IEEE802.4，Rj24

#### 4层：接网输用

1. 应用层：7层中的应用层，表示层，会话层。
   - FTP：文件传输协议
   - SMTP：电子邮件传输协议
   - HTTP：超文本传输协议
2. 传输层：7层中的传输层。
   - TCP：传输控制协议
   - UDP：用户数据报协议
3. 网络层：7层中的网络层。
   - IP：网际协议
   - ICMP：Internet互联网控制报文协议
   - IGMP：Internet组管理协议
4. 链路层（数据链路层、网络接口层）：7层中的数据链路层、物理层。
   - Ethernet：以太网协议，现在大部分局域网都是这种，无连接（没有三次握手），不可靠（没有数据帧号，丢了不知道）
   - ATM：异步传输模式（信元传输）
   - Frame Relay：帧中继（数据帧传输，已经过时了）

## 2、TCP三次握手和四次挥手

TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP的运输连接有三个过程，即建立连接、数据传输和连接释放。

TCP连接建立过程中要解决以下三个问题

* 要使每一方都能够确认对方的存在
* 要允许双方协商一些参数
* 能够对运输实体资源进行分配

TCP连接的建立采用客户机／服务器模式，主动发起连接建立的应用进程叫做客户机，而被动等待连接建立的应用进程叫做服务器。

#### TCP连接的建立过程

[picture1]
<img src="D:\workkkkkkkk\资料\LearningNotes-master\Network\三次握手.png" style="zoom:80%;" />

－客户机：服务器，我想要和你建立连接，你同意吗？（SYN＝１）

－服务器：客户机，我同意和你建立连接（ACK＝１）；我也想和你建立连接，你同意吗？（SYN＝１）

－客户机：服务器，我同意和你建立连接。（ACK＝１）

其实，在进行第二次握手时（即服务器向客户机进行应答时），可以看作时发了两次包，先回答客户机的服务请求（ACK＝１，ask＝x+１），然后再向客户机发出请求（SYN＝１，seq＝ｙ）



#### TCP连接的释放过程

[picture2]
<img src="D:\workkkkkkkk\资料\LearningNotes-master\Network\四次挥手.png" style="zoom:80%;" />

-客户机：服务器，我想和你断开连接，你同意吗？（FIN=1）

-服务器：我同意（ACK=1）

（在此期间，服务器可能还会向客户机发送数据，但是客户机却不能再向服务器发送数据）

-服务器：客户机，我想要和你断开连接，你同意吗？（FIN=1）

-客户机：我同意。（ACK=1）

再等待2MSL时间后就真正断开了连接。



#### 常见问题：

**1、三次握手中，为什么客户机最后还要再向服务器发送一次确认呢？**

答：这是为了防止已失效的连接请求报文段突然又传到了服务器。

所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常的情况，客户机发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户机再重传了一次连接请求，后来收到了确认，建立了连接。数据传输完后，就释放了连接。客户机共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有所谓的“已失效的连接请求报文段”。

但是如果出现了一种异常情况，即客户机发出的第一个报文段并没有丢失，而是在某个节点上长时间滞留了，直至客户机向服务器发送了第二个报文段并且已经完成数据传输释放了连接，此时，第一个报文到达服务器后会被误以为是客户机重新发起的一次连接请求，实质上是一个早已失效的连接请求。如果没有第三次握手，那么这个连接就建立了，但是客户机并不会向服务器发送任何请求，这样连接就会一直持续，白白的消耗网络资源。

**2、为什么客户机发送完最后一个数据后要在TIME-WAIT状态等待 2MSL（四分钟）的时间呢？**

答：第一，为了保证客户机最后发送的那个ACK报文段能够到达服务器。这个ACK报文段可能会丢失。因而使处在LAST-ACK状态的 B 收不到对已发送的FIN＋ACK报文段的确认。服务器会超时重传这个FIN＋ACK报文段，而客户机就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着客户机重传一次确认，重新启动2MSL计时器，最后客户机和服务器都可以进入到CLOSED（关闭）状态。如果没有2MSL等待时间，那么就无法收到重传的FIN+ ACK包，无法进入正常的CLOSED状态。

第二，防止“已失效的连接请求报文段”出现在本连接中。客户机在发送完最后一个ACK报文段，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

**3、三次握手为什么不能改成两次握手？**
答：三次握手中的每一次都是必须的。如果是两次握手，在第二次结束后，服务器并不能保证客户端已经收到了第二次的请求，如此一来的话，服务器会一直保存着这个通信过程，因为TCP通信都是要占用端口的，造成了一定的资源浪费。所以，就一定要让客户端来发送ACK的确认请求。

**4、关闭的时候为什么会是四次挥手？**
答：四次挥手不能像三次握手一样，三次握手可以将ACK+SYN 一起发送，ACK用于确认信息，SYN却是用来建立联机的；四次挥手中ACK是不能和FIN一起发送，ACK只是告诉客户端确认我收到了，等我将数据发送完毕之后会向其发送FIN的标志，所以四次挥手是不能够改变的。



## 3、TCP保证传输可靠性
TCP协议保证传输可靠的方法主要有：**校验和，序列号，确认应答，超时重传，连接管理，流量控制，拥塞控制**。

#### 3.1 校验和

* 判断传输数据是否出现了修改
* 添加12个字节的**伪首部**：4字节源ip + 4字节目的ip + 1字节resv置0 + 1字节传输层协议号（TCP是6，UDP是17）+ 2字节TCP报文长度（TCP首部+数据）
* 伪首部的作用：计算检验和，通过目的IP地址判断地址，通过传输层协议号判断传输协议是否正确
* 校验和的计算：
  1. 发送端将伪首部、TCP报文头、TCP数据分为16位的整数，如果总长度为奇数，则在最后添加一个0
  2. 把TCP报头中的校验和字段置为0
  3. 对每个16bit进行二进制反码的求和
  4. 将校验和存到TCP首部的校验和字段中
  5. 接收端将所有原码相加，高位叠加到低位，如果计算结果的16bit中每一位都是1，则正确

举例：

```c++
/*4bit为例*/
//发送端计算
数据： 1000 0100 校验和： 0000
反码： 0111 1011         1111
叠加： 0111+1011+1111 = 0010 0001
高4bit叠加到低4bit： 0001 + 0010 = 0011，即校验和为 0011
//接收端计算
数据： 1000 0100 校验和： 0011
反码： 0111 1011        1100
叠加： 0111+1011+1100 = 0001 1110
高4bit叠加到低4bit： 0001 + 1110 = 1111，全为 1，则正确
```



#### 3.2 序列号与确认应答

* 序列号：TCP传输时将每个字节的数据都进行了编号

* 确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。序列号的作用不仅仅是应答的作用，序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

#### 3.3 超时重传

TCP使用超时重传机制来解决问题，发送端在发送数据之后，会等待一段时间，如果时间到达后，还没收到ACK报文，则重新发送刚才的数据。接收端在接收到重发的数据，会从序列号中确认数据是否已经接收过，如果没有接收过，则接收数据，并返回ACK报文；如果已经接收过，则直接抛弃，返回ACK报文。

超时时间：在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。

#### 3.4 连接管理

三次握手VS四次挥手 机制

三次握手

1. 客户端发送SYN包（SYN=1，seq=x）到客户端并进入SYN_SEN状态。
2. 服务端收到客户端的SYN包后，发送一个SYN+ACK包（ACK=1，SYN=1，seq=y，ack=x+1）到客户端，并进入SYN_RCVD状态。
3. 客户端收到服务器的SYN+ACK包后，向服务器发送ACK包（ACK=1，seq=x+1，ack=y+1），表示连接成功，服务端和客户端进入established（连接成功）状态。

四次挥手

1. 客户端向服务端发送FIN包（FIN=1，seq=x），表示要断开连接，并且客户端不再向服务端发送数据，客户端进入FIN-WAIT-1状态。
2. 服务端收到客户端的FIN包后，需要向客户端发送ACK（ACK=1，seq=y，ack=x+1）包，表示自己已经收到。此时服务端进入CLOSE-WAIT状态，这时，客户端虽然不再发送数据，但是会继续接受服务端的数据。客户端在接收到ACK包后，会进入FIN-WAIT-2状态。
3. 服务端已经把所有的数据都发生完毕，就会向客户端发送FIN包（FIN=1，ACK=1，seq=z，ack=x+1），并进入LAST-ACK态。
4. 客户端接收到服务端的FIN包后，会发生ACK包（ACK=1，seq=x+1，ack=z+1），并进入TIME-WAIT状态。但此时，客户端还不会断开TCP连接，而是要经过2*MSL（最长报文段时间），才会关闭连接。

#### 3.5 滑动窗口

* **流量控制**和**拥塞控制**都是通过滑动窗口来实现的。

* 滑动窗口：发送缓存中可以发送的数据的序列号范围。只有在滑动窗口之内的数据才能被发送，并且在发送数据，接收到ACK报文之后，该窗口会向前滑动。而滑动窗口的大小是记录在TCP首部中16位的窗口字段。窗口的大小由接收端的接收窗口和拥塞窗口控制的。

#### 3.6 流量控制

* 流量控制机制：TCP根据接收端对数据的处理能力，决定发送端的发送速度
* 窗口大小的内容实际上是接收端数据缓冲区的剩余大小。接收端在发送ACK报文时，将自己的即时窗口大小填入，发送端根据ACK报文里的窗口大小的值改变自己的发送速度
* 如果发送端接收到的窗口大小为0，发送端会停止发送数据，并定期地向接收端发送1字节的探测报文，对方会在此时回应自身的窗口大小，如果结果仍为0，则重设持续计时器，继续等待

#### 3.7 拥塞控制

* 拥塞控制机制：防止过多的数据注入到网络中，这样可以使路由器或链路不至于过载
* 慢开始，拥塞控制
* 快重传，快恢复

建立连接时，窗口的大小（cwnd）为1，并且每当接收到一个ACK报文时，cwnd增加到原来的两倍，直到cwnd到达慢启动的阈值（ssthresh），之后使用拥塞避免算法，cwnd线性增长，每次只增加1。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会变为拥塞窗口的大小的一半，同时拥塞窗口重置为 1。

![](D:\workkkkkkkk\资料\LearningNotes-master\Network\慢开始.png)

当按序发送报文段M1、M2、M3、M4时，如果丢失了M3，即接收端在收到M2后，没有收到M3，直接收到了M4，快重传要求接收方在收到一个失序的报文段（M4）后就立即发出对M2的重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。

与快重传配合使用的还有快恢复算法，其过程有以下两个要点：

1. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
2. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

![](D:\workkkkkkkk\资料\LearningNotes-master\Network\快重传.png)

#### 注意

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。快恢复算法是为了应对网络出现了短暂的拥塞，如：只丢失了一个包，之后网络恢复了正常，那么发送端才会接收到连续三个重复确认，这种情况下，使用快恢复算法就不会导致网络拥塞，并且提高了传输速率。而慢开始算法是为了应对网络长时间的拥塞，因为在这种情况下，发送端不会收到三个重复确认（ACK包因为网络拥塞而丢包了），而导致了超时，所以需要使用慢开始，来缓解网络中的拥塞问题。



