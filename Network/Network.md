## 1、计算机网络分层



计算机网络中会把网络结构分层，目前主要有2种

* 7层 （osi国际标准组织定制）
* 4层（tcp/ip标准，美国军方制定）

#### 7层：物链网输会使用

1. 应用层：用户交互。协议：FTP（文件传输协议），SMTP（电子邮件传输协议），HTTP（超文本传输协议）
2. 表示层：数据处理（加密，格式转换，压缩和恢复），人类语言变成机器语言。协议：ASCII码       
3. 会话层：建立连接，添加校验点，在链接失效时重新连接同步数据（大文件传输）。协议：ADSP，ASP
4. 传输层：端到端通讯，两个主机的进程之间的数据传输和通讯（可靠传输，不可靠传输）。协议：TCP（可靠传输，3次握手保证建立连接，双工通讯（双方同时发送和接受数据），利用缓存保证数据完整有序，添加了序号和确认号验证数据完整性（比如3次握手演示中中经常出现的的seq和ack），电子邮件一类的一般使用这个，保证可靠性，不用太在意即时性），UDP（不可靠传输，一直发送，没有流量控制（有多少发多少），不纠错，一般视频会议一类的使用这个，保证数据速度和即时性，偶尔掉帧什么的无所谓）
5. 网络层： 选择最佳路径，控制发送端流量，纠错（保证传输层数据正确），阻塞控制（控制整体流量）。协议：IP
6. 数据链路层：数据组装成帧（把一个大数据分成一个一个的数据帧101010101010011。。。方便物理层传输）
7. 物理层：物理媒体上数据比特流的透明传输 （把 0 1 数据帧变成高低电压信号传输出去）。协议：IEEE802.4，Rj24

#### 4层：接网输用

1. 应用层：7层中的应用层，表示层，会话层。
   - FTP：文件传输协议
   - SMTP：电子邮件传输协议
   - HTTP：超文本传输协议
2. 传输层：7层中的传输层。
   - TCP：传输控制协议
   - UDP：用户数据报协议
3. 网络层：7层中的网络层。
   - IP：网际协议
   - ICMP：Internet互联网控制报文协议
   - IGMP：Internet组管理协议
4. 链路层（数据链路层、网络接口层）：7层中的数据链路层、物理层。
   - Ethernet：以太网协议，现在大部分局域网都是这种，无连接（没有三次握手），不可靠（没有数据帧号，丢了不知道）
   - ATM：异步传输模式（信元传输）
   - Frame Relay：帧中继（数据帧传输，已经过时了）

## 2、TCP三次握手和四次挥手

TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP的运输连接有三个过程，即建立连接、数据传输和连接释放。

TCP连接建立过程中要解决以下三个问题

* 要使每一方都能够确认对方的存在
* 要允许双方协商一些参数
* 能够对运输实体资源进行分配

TCP连接的建立采用客户机／服务器模式，主动发起连接建立的应用进程叫做客户机，而被动等待连接建立的应用进程叫做服务器。

#### TCP连接的建立过程

[picture1]
<img src="D:\workkkkkkkk\资料\LearningNotes-master\Network\三次握手.png" style="zoom:80%;" />

－客户机：服务器，我想要和你建立连接，你同意吗？（SYN＝１）

－服务器：客户机，我同意和你建立连接（ACK＝１）；我也想和你建立连接，你同意吗？（SYN＝１）

－客户机：服务器，我同意和你建立连接。（ACK＝１）

其实，在进行第二次握手时（即服务器向客户机进行应答时），可以看作时发了两次包，先回答客户机的服务请求（ACK＝１，ask＝x+１），然后再向客户机发出请求（SYN＝１，seq＝ｙ）



#### TCP连接的释放过程

[picture2]
<img src="D:\workkkkkkkk\资料\LearningNotes-master\Network\四次挥手.png" style="zoom:80%;" />

-客户机：服务器，我想和你断开连接，你同意吗？（FIN=1）

-服务器：我同意（ACK=1）

（在此期间，服务器可能还会向客户机发送数据，但是客户机却不能再向服务器发送数据）

-服务器：客户机，我想要和你断开连接，你同意吗？（FIN=1）

-客户机：我同意。（ACK=1）

再等待2MSL时间后就真正断开了连接。



#### 常见问题：

**1、三次握手中，为什么客户机最后还要再向服务器发送一次确认呢？**

答：这是为了防止已失效的连接请求报文段突然又传到了服务器。

所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常的情况，客户机发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户机再重传了一次连接请求，后来收到了确认，建立了连接。数据传输完后，就释放了连接。客户机共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有所谓的“已失效的连接请求报文段”。

但是如果出现了一种异常情况，即客户机发出的第一个报文段并没有丢失，而是在某个节点上长时间滞留了，直至客户机向服务器发送了第二个报文段并且已经完成数据传输释放了连接，此时，第一个报文到达服务器后会被误以为是客户机重新发起的一次连接请求，实质上是一个早已失效的连接请求。如果没有第三次握手，那么这个连接就建立了，但是客户机并不会向服务器发送任何请求，这样连接就会一直持续，白白的消耗网络资源。

**2、为什么客户机发送完最后一个数据后要在TIME-WAIT状态等待 2MSL（四分钟）的时间呢？**

答：第一，为了保证客户机最后发送的那个ACK报文段能够到达服务器。这个ACK报文段可能会丢失。因而使处在LAST-ACK状态的 B 收不到对已发送的FIN＋ACK报文段的确认。服务器会超时重传这个FIN＋ACK报文段，而客户机就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着客户机重传一次确认，重新启动2MSL计时器，最后客户机和服务器都可以进入到CLOSED（关闭）状态。如果没有2MSL等待时间，那么就无法收到重传的FIN+ ACK包，无法进入正常的CLOSED状态。

第二，防止“已失效的连接请求报文段”出现在本连接中。客户机在发送完最后一个ACK报文段，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

**3、三次握手为什么不能改成两次握手？**
答：三次握手中的每一次都是必须的。如果是两次握手，在第二次结束后，服务器并不能保证客户端已经收到了第二次的请求，如此一来的话，服务器会一直保存着这个通信过程，因为TCP通信都是要占用端口的，造成了一定的资源浪费。所以，就一定要让客户端来发送ACK的确认请求。

**4、关闭的时候为什么会是四次挥手？**
答：四次挥手不能像三次握手一样，三次握手可以将ACK+SYN 一起发送，ACK用于确认信息，SYN却是用来建立联机的；四次挥手中ACK是不能和FIN一起发送，ACK只是告诉客户端确认我收到了，等我将数据发送完毕之后会向其发送FIN的标志，所以四次挥手是不能够改变的。



## 3、TCP保证传输可靠性
TCP协议保证传输可靠的方法主要有：**校验和，序列号，确认应答，超时重传，连接管理，流量控制，拥塞控制**。

#### 3.1 校验和

* 判断传输数据是否出现了修改
* 添加12个字节的**伪首部**：4字节源ip + 4字节目的ip + 1字节resv置0 + 1字节传输层协议号（TCP是6，UDP是17）+ 2字节TCP报文长度（TCP首部+数据）
* 伪首部的作用：计算检验和，通过目的IP地址判断地址，通过传输层协议号判断传输协议是否正确
* 校验和的计算：
  1. 发送端将伪首部、TCP报文头、TCP数据分为16位的整数，如果总长度为奇数，则在最后添加一个0
  2. 把TCP报头中的校验和字段置为0
  3. 对每个16bit进行二进制反码的求和
  4. 将校验和存到TCP首部的校验和字段中
  5. 接收端将所有原码相加，高位叠加到低位，如果计算结果的16bit中每一位都是1，则正确

举例：

```c++
/*4bit为例*/
//发送端计算
数据： 1000 0100 校验和： 0000
反码： 0111 1011         1111
叠加： 0111+1011+1111 = 0010 0001
高4bit叠加到低4bit： 0001 + 0010 = 0011，即校验和为 0011
//接收端计算
数据： 1000 0100 校验和： 0011
反码： 0111 1011        1100
叠加： 0111+1011+1100 = 0001 1110
高4bit叠加到低4bit： 0001 + 1110 = 1111，全为 1，则正确
```



#### 3.2 序列号与确认应答

* 序列号：TCP传输时将每个字节的数据都进行了编号

* 确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。序列号的作用不仅仅是应答的作用，序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

#### 3.3 超时重传

TCP使用超时重传机制来解决问题，发送端在发送数据之后，会等待一段时间，如果时间到达后，还没收到ACK报文，则重新发送刚才的数据。接收端在接收到重发的数据，会从序列号中确认数据是否已经接收过，如果没有接收过，则接收数据，并返回ACK报文；如果已经接收过，则直接抛弃，返回ACK报文。

超时时间：在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。

#### 3.4 连接管理

三次握手VS四次挥手 机制

三次握手

1. 客户端发送SYN包（SYN=1，seq=x）到客户端并进入SYN_SEN状态。
2. 服务端收到客户端的SYN包后，发送一个SYN+ACK包（ACK=1，SYN=1，seq=y，ack=x+1）到客户端，并进入SYN_RCVD状态。
3. 客户端收到服务器的SYN+ACK包后，向服务器发送ACK包（ACK=1，seq=x+1，ack=y+1），表示连接成功，服务端和客户端进入established（连接成功）状态。

四次挥手

1. 客户端向服务端发送FIN包（FIN=1，seq=x），表示要断开连接，并且客户端不再向服务端发送数据，客户端进入FIN-WAIT-1状态。
2. 服务端收到客户端的FIN包后，需要向客户端发送ACK（ACK=1，seq=y，ack=x+1）包，表示自己已经收到。此时服务端进入CLOSE-WAIT状态，这时，客户端虽然不再发送数据，但是会继续接受服务端的数据。客户端在接收到ACK包后，会进入FIN-WAIT-2状态。
3. 服务端已经把所有的数据都发生完毕，就会向客户端发送FIN包（FIN=1，ACK=1，seq=z，ack=x+1），并进入LAST-ACK态。
4. 客户端接收到服务端的FIN包后，会发生ACK包（ACK=1，seq=x+1，ack=z+1），并进入TIME-WAIT状态。但此时，客户端还不会断开TCP连接，而是要经过2*MSL（最长报文段时间），才会关闭连接。

#### 3.5 滑动窗口

* **流量控制**和**拥塞控制**都是通过滑动窗口来实现的。

* 滑动窗口：发送缓存中可以发送的数据的序列号范围。只有在滑动窗口之内的数据才能被发送，并且在发送数据，接收到ACK报文之后，该窗口会向前滑动。而滑动窗口的大小是记录在TCP首部中16位的窗口字段。窗口的大小由接收端的接收窗口和拥塞窗口控制的。

#### 3.6 流量控制

* 流量控制机制：TCP根据接收端对数据的处理能力，决定发送端的发送速度
* 窗口大小的内容实际上是接收端数据缓冲区的剩余大小。接收端在发送ACK报文时，将自己的即时窗口大小填入，发送端根据ACK报文里的窗口大小的值改变自己的发送速度
* 如果发送端接收到的窗口大小为0，发送端会停止发送数据，并定期地向接收端发送1字节的探测报文，对方会在此时回应自身的窗口大小，如果结果仍为0，则重设持续计时器，继续等待

#### 3.7 拥塞控制

* 拥塞控制机制：防止过多的数据注入到网络中，这样可以使路由器或链路不至于过载
* 慢开始，拥塞控制
* 快重传，快恢复

建立连接时，窗口的大小（cwnd）为1，并且每当接收到一个ACK报文时，cwnd增加到原来的两倍，直到cwnd到达慢启动的阈值（ssthresh），之后使用拥塞避免算法，cwnd线性增长，每次只增加1。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会变为拥塞窗口的大小的一半，同时拥塞窗口重置为 1。

![](D:\workkkkkkkk\资料\LearningNotes-master\Network\慢开始.png)

当按序发送报文段M1、M2、M3、M4时，如果丢失了M3，即接收端在收到M2后，没有收到M3，直接收到了M4，快重传要求接收方在收到一个失序的报文段（M4）后就立即发出对M2的重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。

与快重传配合使用的还有快恢复算法，其过程有以下两个要点：

1. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
2. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

![](D:\workkkkkkkk\资料\LearningNotes-master\Network\快重传.png)

#### 注意

在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。快恢复算法是为了应对网络出现了短暂的拥塞，如：只丢失了一个包，之后网络恢复了正常，那么发送端才会接收到连续三个重复确认，这种情况下，使用快恢复算法就不会导致网络拥塞，并且提高了传输速率。而慢开始算法是为了应对网络长时间的拥塞，因为在这种情况下，发送端不会收到三个重复确认（ACK包因为网络拥塞而丢包了），而导致了超时，所以需要使用慢开始，来缓解网络中的拥塞问题。

## 4、TCP/IP socket编程

* socket是TCP/IP协议的API，TCP/IP只是一个协议栈，需要具体实现，同时还要提供对外标准的编程接口，这就是Socket编程接
* socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等
* 局域网通过UDP实现服务端和客户端的通信， UDP的服务端不需要执行listen函数和accept函数
* 服务端:
  服务器端初始化socket，然后与端口绑定，对端口进行监听，调用accept阻塞，等待客户端连接。
  socket() -> bind() -> listen() -> accept()
* 客户端：
  客户端先初始化socket，然后与服务端连接，服务端监听成功则连接建立完成。
  socket() -> connect()

#### socket基本过程

![](D:\workkkkkkkk\资料\LearningNotes-master\Network\socket编程步骤.png)



| TCP编程的服务器端一般步骤                                    | UDP编程的服务器端一般步骤                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1、创建一个socket，用函数socket();<br />2、设置socket属性，用函数setsockopt(); *可选<br />3、绑定IP地址、端口等信息到socket上，用函数bind();<br />4、开启监听，用函数listen();<br />5、接收客户端上来的连接，用函数accept();<br />6、收发数据，用函数send()和recv()，或者read()和write()；<br />7、关闭网络连接；<br />8、关闭监听； | 1、创建一个socket，用函数socket();<br />2、设置socket属性，用函数setsockopt(); *可选<br />3、绑定IP地址、端口等信息到socket上，用函数bind();<br />4、循环接收数据，用函数recvfrom();<br />5、关闭网络连接； |

| TCP编程的客户端一般步骤                                      | UDP编程的客户端一般步骤                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1、创建一个socket，用函数socket()；<br />2、设置socket属性，用函数setsockopt()； *可选<br />3、绑定IP地址、端口等信息到socket上，用函数bind()；<br />4、设置要连接的对方的IP地址和端口等属性；<br />5、连接服务器，用函数connect()；<br />6、收发数据，用函数send()和recv()，或者read()和write()；<br />7、关闭网络连接；<br /> | 1、创建一个socket，用函数socket();<br />2、设置socket属性，用函数setsockopt(); *可选<br />3、绑定IP地址、端口等信息到socket上，用函数bind();<br />4、设置对方的IP地址和端口等属性；<br />5、发送数据，用sendto()；<br />6、关闭网络连接； |

#### 问题

**1、为什么要创建三个线程去处理三个函数，单个线程并不可以吗，多线程和单线程处理起来有什么不同？**

答：首先，这里用到多线程的目的是为了提高处理能力，减少等待时间，多线程可以并发执行，即可以同时对三个函数进行处理，处理起来会快很多。这里也是可以用单线程来处理的，但是单线程每次只能做一件事情，不能同时去获得连接套接字、发送消息、接收消息，这样在做其中一件事情的时候其他的两件事情就要等待，这样处理时间会比多线程慢很多。多线程可以及时的响应，单线程不能及时响应。

## 5、TIME_WAIT

TCP连接全双工：数据在两个方向上能同时传递。

因此每个方向必须单独地进行关闭。即当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。

#### TIME_WAIT的作用（存在此状态的原因）

1. 可靠地实现TCP全双工连接的终止

   在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。

   在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果最终发送的ACK丢失，被动关闭的一端（一般是服务端）会重传最终的FIN包，如果执行主动关闭的一端没有维护这个连接的状态信息，会发送RST包响应，导致连接不正常关闭。

2. 允许老的重复分节在网络中消逝
   TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。
   在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。
   为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。

   设在一个连接关闭后，发起建立连接的一端（客户端）立即重用原来的端口、IP地址和服务端建立新的连接。老的连接上的分组可能在新的连接建立后到达服务端，TCP必须防止来自某个连接的老的重复分组在连接终止后再现，从而被误解为同一个连接的化身。要实现这种功能，TCP不能给处于TIME_WAIT状态的连接启动新的连接。
   
   

#### TIME_WAIT过多的影响

在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

* 高并发：高并发使得服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
* 短连接：短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。这里有个相对长短的概念，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。而长连接对应的业务的并发量并不会很高。

#### 如何处理TIME_WAIT过多

简单来说，就是打开系统的TIMEWAIT重用和快速回收。

编辑内核文件/etc/sysctl.conf，加入以下内容：

```makefile
net.ipv4.tcp_syncookies = 1   #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1     #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1   #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout = xx #修改系默认的 TIMEOUT 时间
```

然后执行 /sbin/sysctl -p 让参数生效

```
/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。
```

如果效果不理想，可以继续修改配置：

```makefile
vi /etc/sysctl.conf
net.ipv4.tcp_keepalive_time = 1200 
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.ip_local_port_range = 1024 65000 
#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
net.ipv4.tcp_max_syn_backlog = 8192 
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_tw_buckets = 5000 
#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
#默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
```




## 6、ARP协议

#### ARP的产生及原理

ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，它就是通过地址解析协议获得的。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。

在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。ARP协议通过接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。

#### ARP映射的方式

##### 静态映射

静态映射的意思是要手动创建一张ARP表，把逻辑（IP）地址和物理地址关联起来。这个ARP表储存在网络中的每一台机器上。

例如，知道其机器的IP地址但不知道其物理地址的机器就可以通过查ARP表找出对应的物理地址。这样做有一定的局限性，因为物理地址可能发生变化。

##### 动态映射

动态映射时，每次只要机器知道另一台机器的逻辑（IP）地址，就可以使用协议找出相对应的物理地址。已经设计出的实现了动态映射协议的有ARP和RARP两种。ARP把逻辑（IP）地址映射为物理（MAC）地址。RARP把物理（MAC）地址映射为逻辑（IP）地址。

#### ARP工作流程

##### ARP请求

任何时候，当主机需要找出这个网络中的另一个主机的物理地址时，它就可以发送一个ARP请求报文，这个报文包好了发送方的MAC地址和IP地址以及接收方的IP地址。因为发送方不知道接收方的物理地址，所以这个查询分组会在网络层中进行广播。

##### ARP响应

局域网中的每一台主机都会接受并处理这个ARP请求报文，然后进行验证，查看接收方的IP地址是不是自己的地址，只有验证成功的主机才会返回一个ARP响应报文，这个响应报文包含接收方的IP地址和物理地址。这个报文利用收到的ARP请求报文中的请求方物理地址以单播的方式直接发送给ARP请求报文的请求方。

#### ARP协议报文格式

![在这里插入图片描述](https://img-blog.csdn.net/20180419180040413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2ZXJfcGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* 硬件类型：2字节，用来定义运行ARP的网络类型。每个局域网基于其类型被指派一个整数。例如：以太网的类型为1。ARP可用在任何物理网络上。
* 协议类型：2字节，用来定义使用的协议。例如：对IPv4协议这个字段是0800。ARP可用于任何高层协议
* 硬件长度：1字节，用来定义物理地址的长度，以字节为单位。例如：对于以太网的值为6。
* 协议长度：1字节，用来定义逻辑地址的长度，以字节为单位。例如：对于IPv4协议的值为4。
* 操作码：2字节，用来定义报文的类型。已定义的分组类型有两种：ARP请求（1），ARP响应（2）。
* 源硬件地址：这是一个可变长度字段，用来定义发送方的物理地址。例如：对于以太网这个字段的长度是6字节。
* 源逻辑地址：这是一个可变长度字段，用来定义发送方的逻辑（IP）地址。例如：对于IP协议这个字段的长度是4字节。
* 目的硬件地址：这是一个可变长度字段，用来定义目标的物理地址，例如，对以太网来说这个字段位6字节。对于ARP请求报文，这个字段为全0，因为发送方并不知道目标的硬件地址。
* 目的逻辑地址：这是一个可变长度字段，用来定义目标的逻辑（IP）地址，对于IPv4协议这个字段的长度为4个字节。

#### ARP报文长度

帧：是在数据链路层传输的数据格式

ARP报文总长度64字节。

ARP报文 = 以太网帧头（14字节） + ARP报文头（28字节）= 42字节

以太网帧头 = 目的mac（6字节）+源mac（6字节）+帧类型（2字节）

真正发包的时为了保证以太网帧的最小帧长为 64 字节，会在报文里添加一个padding字段，用来填充数据包大小。

#### ARP报文抓包

ARP请求报文（目的地址填全F）

![](https://img-blog.csdn.net/2018041918011326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2ZXJfcGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

ARP应答报文（添加自己的目的地址）

![](https://img-blog.csdn.net/20180419180144277?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V2ZXJfcGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### RARP工作流程

1. 发送一个本地的RARP广播包，在其中声明自己的MAC地址并请求所有收到此包的RARP服务器分配一个IP地址。
2. 在本地网段上的RARP服务器收到请求之后，检查RARP列表，查找MAC地址对应的IP地址。
3. 如果存在，RARP服务器给源主机发送一个响应数据包，并将IP地址提供给对方使用，如果不存在则不作任何响应
4. 源主机如果收到响应数据包则利用得到的IP地址进行通信，如果一直没有收到RARP 服务器响应数据包则表示初始化失败。

## 7、IP协议

#### IP地址格式

* IPV4：32bit，4字节，十进制和二进制
  * 点分四组十进制，每一组范围[0,255]：255.255.255.255
  * 二进制：11111111 11111111 11111111 11111111
* IPV6：128bit，16字节
  * 8个字段，每个字段包括4个十六进制数，由冒号分隔：FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF
  * IPv6可以兼容IPv4地址，IPv6块值为ffff，其后面紧跟“点分四组”的格式，低32位通常采用点分四组的表示法（::ffff:10.0.0.1表示10.0.0.1）

#### IP地址结构

##### 分类寻址

IPV4被分为五大类：ABCDE

* A类为：点分四组中的第一组地址范围为0-127的IP地址。以二进制来看就是“首位为0”，网络号8位
* B类：128-191，二进制首位为10，网络号16位
* C类：192-223，二进制首位为110，网络号24位
* D类：224-239，二进制首位为1110
* E类：240-255，二进制首位为1111

##### 子网寻址

IP地址 = 网络号 + 子网号 + 主机号

原来是将IP地址分为一个网络号和一个主机号，现在将主机号再分成一个子网号和一个主机号

原因是：原有的A类和B类地址为主机号分配了太多的空间，事实上一个网络中，并不需要很多主机

分配方式：

1. 网络信息中心集中分配每一个网络号。
2. 各个站点的管理人员再分配他们网络号下的子网ID和对应的主机ID。
3. 然后管理员再安排每一个子网下面的主机数。

##### 子网掩码

除了IP地址外，主机还需要知道有多少bit用于子网号，多少bit用于主机号，这就需要子网掩码来确定

子网掩码是一个32bit的值，其中值为1的bit留给网络号和子网号，值为0的bit留给主机号

* 根据本机IP地址，可以知道网络号和子网号的分界线（从IP地址高位得知是A类、B类、C类地址）
* 根据子网掩码，可以知道子网号和主机号的分界线

##### 广播地址

每个子网的第一个和最后一个地址无效。

* “子网掩码.0”（子网的第一个地址），意味着该ip地址不指向某一个主机，而是表示“子网标识符”。

* “子网掩码.255”（子网的最后一个地址），表示了“该子网下的所有主机”。从而引出了广播地址。

IP网络上发送信息都是要有准确的ip地址的，假设要给“统一网络下的”10台主机发信息，那么就得写10个精准的ip地址。而利用广播地址，我们就能通过一条ip地址，将信息发送给某个子网下的所有主机。即：只写出网络号和子网号，而将主机ID部分用.255代替。

计算一个站点的广播地址也要用到子网掩码，计算方法如下：

1. 首先将站点的子网掩码“取反”（1变0,0变1）。
2. 然后与站点ip地址进行“按位或”运算（1或0的1,0或0的0,1或1得1）。
3. 这样就既能保留网络号和子网号的地址，然后又能将主机号部分替换为255。

##### 前缀（CIDR）

CIDR的网络号由前缀来控制，如222.80.18.18/25，其中“/25”表示其前面地址中的前25位代表网络号，其余位数代表主机ID。

写法是在现有的点分四组后面加上"/前缀"，如：128.0.0.0/24

##### 特殊地址

比较为人们所熟知的是127.0.0.1，指向本机。实际上整个127段都是主机回送地址。

也就是说127.0.0.0/8是特殊地址（前缀8将127框住，后面可随意组合）。127.0.0.1~127.255.255.255之间的地址都会回送本机。

##### 组播地址

组播IP地址使用的是D类网。

使用组播IP地址作为目的地址，已加入“组”的所有主机都将接收发送到该组的任何数据报。

发送方甚至不知道有多少主机接收到数据报。

#### IP协议

最高位在左边，记为0bit；最低位在右边，记为31bit。

传输次序为0-7bit，8-15bit...这样，称为大端字节序（big endian）。TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此又称为网络字节序。

数据的封装

![](https://img-blog.csdn.net/20180415193605824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4aGlv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中IP首部的结构如下：

![](https://images2015.cnblogs.com/blog/916092/201707/916092-20170707142324331-1201756642.png)

##### 版本（4bit）

* IPV4：4
* IPV6：6

##### 首部长度

* 正常值为5，最大值为15

##### 总长度

* 指IP数据报的长度，以字节为单位

##### 协议（8bit）

* ICMP：1
* IGMP：2
* TCP：6
* UDP：17

##### 首部校验和

该字段“仅计算”IPv4首部。也就是说只“校验”首部。并不检查数据报的“数据部分”。ICMP、IGMP、TCP、UDP在它们各自的首部中均含有同时覆盖首部和数据检验和码。

#### IP转发



